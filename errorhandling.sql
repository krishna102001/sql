-- ERROR HANDLING 
-- @@ERROR INTRODUCED IN SQL SERVER 2000 , SOMETIME SYSTEM FUNCTIONS TAHT BEGINS WITH @@ SIGN IS CALLED AS GLOBAL VARIABLE, THEY DOESN'T BEHAVE LIKE A VARIABLE
-- TRY...CATCH INTRODUCED IN 2005 & LATER

-- RAISERROR SYNTAX
-- RAISEERROR('ERROR MESSAGE', ERROR SEVERITY, ERROR STATE)
-- IN RAISERROR STATE IS START FROM 1 TO 127 ONLY

-- CREATE TABLE PRODUCT(
--     PRODUCTID INT NOT NULL PRIMARY KEY IDENTITY(1,1),
--     NAME NVARCHAR(10),
--     UNITPRICE INT,
--     QTYAVAILABLE INT
-- )
-- INSERT INTO PRODUCT VALUES('DESKTOP',3467,50)
-- CREATE TABLE TBLPRODUCTSALES(
--     PRODUCTSALESID INT,
--     PRODUCTID INT,
--     QUANTITYSOLD INT
-- )
SELECT * FROM PRODUCT
SELECT * FROM TBLPRODUCTSALES

CREATE PROC SPSELLPRODUCT
@PRODUCTID INT,
@QUANTITYTOSELL INT
AS 
BEGIN
    DECLARE @STOCKAVAILABLE INT
    SELECT @STOCKAVAILABLE = QTYAVAILABLE FROM PRODUCT WHERE PRODUCTID = @PRODUCTID
    -- THROW ERROR IF STOCK IS NOT AVALIABLE
    IF(@STOCKAVAILABLE < @QUANTITYTOSELL)
    BEGIN
        RAISERROR('STOCK IS OVER',16,1)
        RETURN
    END
    ELSE
        BEGIN
            BEGIN TRANSACTION
                UPDATE PRODUCT SET QTYAVAILABLE = (QTYAVAILABLE - @QUANTITYTOSELL) WHERE PRODUCTID = @PRODUCTID

                DECLARE @MAXPRODUCTSALESID INT
                SELECT @MAXPRODUCTSALESID = CASE WHEN MAX(PRODUCTSALESID) IS NULL THEN 0 ELSE MAX(PRODUCTSALESID) END FROM TBLPRODUCTSALES

                SET @MAXPRODUCTSALESID = @MAXPRODUCTSALESID + 1
                INSERT INTO TBLPRODUCTSALES VALUES(@MAXPRODUCTSALESID,@PRODUCTID,@QUANTITYTOSELL)
                IF(@@ERROR != 0)
                BEGIN
                    ROLLBACK TRANSACTION
                    PRINT 'ROLLBACK SUCCESSFULLY'
                END
                ELSE
                    BEGIN 
                        COMMIT TRANSACTION
                        PRINT 
                    END
        END
END

EXECUTE SPSELLPRODUCT 8,10

-- @@ERROR SYNTAX
-- @@ERROR RETURN NON ZERO VALUES IF THERE IS AN ERROR, OTHERWISE ZERO IS RETURN IF THERE IS NOT ERROR
INSERT INTO PRODUCT VALUES('MOBILE',100,20) 
IF(@@ERROR <> 0)
    PRINT 'ERROR OCCURED'
ELSE 
     PRINT 'NO ERROR OCCURED'

DECLARE @ERROR INT
INSERT INTO PRODUCT VALUES('MOBILE',100,20) 
SET @ERROR = @@ERROR
SELECT * FROM PRODUCT
IF(@ERROR<> 0) 
    PRINT'ERROR OCCURED'
ELSE
    PRINT 'NO ERROR OCCURED'


-- TRY...CATCH

CREATE PROC SPSELLPRODUCT
@PRODUCTID INT,
@QUANTITYTOSELL INT
AS 
BEGIN
    DECLARE @STOCKAVAILABLE INT
    SELECT @STOCKAVAILABLE = QTYAVAILABLE FROM PRODUCT WHERE PRODUCTID = @PRODUCTID
    -- THROW ERROR IF STOCK IS NOT AVALIABLE
    IF(@STOCKAVAILABLE < @QUANTITYTOSELL)
    BEGIN
        RAISERROR('STOCK IS OVER',16,1)
        RETURN
    END
    ELSE
        BEGIN
        BEGIN TRY
            BEGIN TRANSACTION
                UPDATE PRODUCT SET QTYAVAILABLE = (QTYAVAILABLE - @QUANTITYTOSELL) WHERE PRODUCTID = @PRODUCTID

                DECLARE @MAXPRODUCTSALESID INT
                SELECT @MAXPRODUCTSALESID = CASE WHEN MAX(PRODUCTSALESID) IS NULL THEN 0 ELSE MAX(PRODUCTSALESID) END FROM TBLPRODUCTSALES

                SET @MAXPRODUCTSALESID = @MAXPRODUCTSALESID + 1
                INSERT INTO TBLPRODUCTSALES VALUES(@MAXPRODUCTSALESID,@PRODUCTID,@QUANTITYTOSELL)
                COMMIT TRANSACTION
            END TRY
            BEGIN CATCH
                ROLLBACK TRANSACTION
                SELECT ERROR_NUMBER() AS ERRORNUMBER,
                ERROR_MESSAGE() AS ERRORMESSAGE,
                ERROR_LINE() AS ERRORLINE,
                ERROR_SEVERITY() AS ERROR_SEVERITY,
                ERROR_STATE() AS ERRORSTATE,
                ERROR_PROCEDURE() AS ERROR_PROCEDURE
            END CATCH
        END
END

-- TRY... CATCH SYNTAX

BEGIN TRY
    (ANY SET OF SQL STATEMENT)
END TRY
BEGIN CATCH
    [OPTIONAL ANY SQL STATEMENT]
END CATCH