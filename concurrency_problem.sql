CREATE TABLE ACCOUNTS(
    ID INT NOT NULL PRIMARY KEY,
    ACCOUNTNAME NVARCHAR(20),
    BALANCE INT
)

INSERT INTO ACCOUNTS VALUES(1,'MARK',900)
INSERT INTO ACCOUNTS VALUES(2,'MARY',1100)

SELECT * FROM ACCOUNTS

BEGIN TRY
    BEGIN TRANSACTION
        UPDATE ACCOUNTS SET BALANCE = BALANCE - 100 WHERE ID = 1
        UPDATE ACCOUNTS SET BALANCE = BALANCE + 100 WHERE ID = 2
    COMMIT TRANSACTION
    PRINT 'TRANSCATION COMMITTED'
END TRY
BEGIN CATCH
    ROLLBACK TRANSACTION
    PRINT 'TRANSACTION ROLLED BACK'
END CATCH

-- common concurrency problems
CREATE TABLE TBLINVENTORY(
    ID INT PRIMARY KEY ,
    PRODUCT NVARCHAR(20),
    ITEMSTOCK INT
)
INSERT INTO TBLINVENTORY VALUES(1,'iPHONE',10)
SELECT * FROM TBLINVENTORY
-- 1. DIRTY READ PROBLEM
BEGIN TRAN
UPDATE TBLINVENTORY SET ITEMSTOCK = 9 WHERE ID = 1

--BILL THE CUSTOMER
WAITFOR DELAY '00:00:15'
ROLLBACK TRAN

-- RUN THE BELOW CODE IN ANOTHER SERVER
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
SELECT * FROM TBLINVENTORY WHERE ID =1 -- IT WILL GIVE ITEM STOCK = 9 BUT DUE TO ANY REASON CUSTOMER CANCEL THE ORDER AFTER SOMETIME AND BEFORE THE CANCELING THE USER READ THE ITEM STOCK 9 BUT LATER IT GOT BACK TO 10
-- THIS IS CALLED DIRTY READ PROBLEM

-- 2.LOST UPDATE PROBLEMS
-- TRANSACTION 1
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ
BEGIN TRAN
DECLARE @ITEMSTOCK INT

SELECT @ITEMSTOCK = ITEMSTOCK FROM TBLINVENTORY WHERE ID = 1

WAITFOR DELAY '00:00:10'
SET @ITEMSTOCK = @ITEMSTOCK - 1
UPDATE TBLINVENTORY SET ITEMSTOCK = @ITEMSTOCK WHERE ID = 1

PRINT @ITEMSTOCK
COMMIT TRANSACTION

--TRANSCATION 2 RUN IN ANOTHER SERVER , THIS TRANSACTION 2 TAKE LESS TIME SO IT WILL UPDATE THE INVENTORY BUT WHEN TRANSACTION -1  COMPLETED IT ALSO UPDATE THE INVENTORY
-- NOW THE LOST UPDATE PROBLEM IS OCCURED SO TO TACKLE THIS PRBLM WE CAN USE
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ
BEGIN TRAN
DECLARE @ITEMSTOCK INT

SELECT @ITEMSTOCK = ITEMSTOCK FROM TBLINVENTORY WHERE ID = 1

WAITFOR DELAY '00:00:1'
SET @ITEMSTOCK = @ITEMSTOCK - 2
UPDATE TBLINVENTORY SET ITEMSTOCK = @ITEMSTOCK WHERE ID = 1

PRINT @ITEMSTOCK
COMMIT TRANSACTION

SELECT * FROM TBLINVENTORY -- IT SHOWING 9 WHICH IS WRONG IT MUST SHOW 7 ITEMSTOCK


-- 3. NON REPEATABLE READ PROBLEM IN THIS PROBLEM ONE TRANSACTION READ THE SAME DATA TWICE BUT ANOTHER TRANSACTION UPDATES THAT DATA IN BETWEEN
--TRANSACTION 1
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ
BEGIN TRAN

SELECT ITEMSTOCK FROM TBLINVENTORY WHERE ID = 1

WAITFOR DELAY '00:00:10'

SELECT ITEMSTOCK FROM TBLINVENTORY WHERE ID = 1

COMMIT TRANSACTION

--TRANSACTION 2
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ -- THIS WILL HELP TO KEEP THE DATA ACCURATELY
UPDATE TBLINVENTORY SET ITEMSTOCK = 5 WHERE ID =1

-- 4. PHANTOM READS PROBLEM IT HAPPEN WHEN ONE TRANSACTION EXECUTE A QUERY TWICE AND ITS GET A DIFFERENT NO. OF ROWS ITHE RESULTS SET EACH TIME

-- CREATE TABLE TBLEMP(
--     ID INT,
--     NAME NVARCHAR(10)
-- )
-- INSERT INTO TBLEMP VALUES(1,'MARK')
-- INSERT INTO TBLEMP VALUES(3,'SARA')

-- TRANSACTION - 1
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE -- BY THIS WE CAN SOLVE THE PROBLEM FOR PHANTOM READS
BEGIN TRAN
SELECT * FROM TBLEMP WHERE ID BETWEEN 1 AND 3

WAITFOR DELAY '00:00:10'

SELECT * FROM TBLEMP WHERE ID BETWEEN 1 AND 3
COMMIT TRAN 

-- TRANSACTION - 2
INSERT INTO TBLEMP VALUES(2,'MARCUS')
DELETE TBLEMP WHERE ID =2